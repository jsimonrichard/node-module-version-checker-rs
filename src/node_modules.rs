use color_eyre::eyre::Result;
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::rc::{Rc, Weak};
use std::sync::atomic::{AtomicU32, Ordering};

use crate::package_data::PackageJsonData;

lazy_static! {
    pub static ref NEXT_PARENT_ID: AtomicU32 = AtomicU32::new(0);
}

#[derive(Debug)]
pub struct NodeModules {
    id: u32,
    root: PathBuf,
    packages: HashMap<String, Rc<PackageJsonData>>,
    parent: Option<Weak<NodeModules>>,
}

impl NodeModules {
    pub fn from_folder(folder: PathBuf) -> Result<Rc<Self>> {
        Self::new(folder, None, None)
    }

    pub fn create_child(self: &Rc<Self>, folder: PathBuf) -> Result<Rc<Self>> {
        Self::new(folder, Some(Rc::downgrade(self)), None)
    }

    pub fn get_from_path(self: &Rc<Self>, path: &Path) -> Result<Rc<Self>> {
        if path == self.root {
            Ok(self.clone())
        } else {
            self.create_child(path.to_path_buf())
        }
    }

    pub fn new(
        folder: PathBuf,
        parent: Option<Weak<NodeModules>>,
        extra_packages: Option<Vec<PackageJsonData>>,
    ) -> Result<Rc<Self>> {
        let id = NEXT_PARENT_ID.fetch_add(1, Ordering::SeqCst);

        let mut packages = HashMap::new();
        for entry in fs::read_dir(folder.clone())?.flatten() {
            let path = entry.path();

            if !path.is_dir() {
                continue;
            }

            let dir_name = path.file_name().unwrap().to_string_lossy();
            if dir_name.starts_with('@') {
                // Handle scoped packages
                let scoped_entries = fs::read_dir(&path)?;
                for scoped_entry in scoped_entries.flatten() {
                    let scoped_path = scoped_entry.path();
                    if let Some(package_data) =
                        PackageJsonData::from_folder_with_id(&scoped_path, id)?
                    {
                        packages.insert(package_data.name.clone(), Rc::new(package_data));
                    }
                }
            } else {
                // Handle regular packages
                if let Some(package_data) = PackageJsonData::from_folder_with_id(&path, id)? {
                    packages.insert(package_data.name.clone(), Rc::new(package_data));
                }
            }
        }

        if let Some(extra_packages) = extra_packages {
            for package in extra_packages {
                packages.insert(package.name.clone(), Rc::new(package));
            }
        }

        Ok(Rc::new(Self {
            id,
            root: folder,
            packages,
            parent,
        }))
    }

    fn parent(&self) -> Option<Rc<Self>> {
        self.parent
            .as_ref()
            .map(|p| p.upgrade().expect("parent has been dropped"))
    }

    pub fn get_package(&self, name: &str) -> Option<Rc<PackageJsonData>> {
        self.packages.get(name).map(|p| p.clone()).or_else(|| {
            self.parent()
                .and_then(|p| p.get_package(name).map(|p| p.clone()))
        })
    }
}
